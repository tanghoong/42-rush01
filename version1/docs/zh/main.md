# Main.c 文档

## 概述

`main.c` 文件作为程序入口点，协调整个4×4摩天大楼谜题求解过程。本模块处理命令行参数验证，协调解析-求解-输出管道，并根据42学校标准管理整体程序流程和适当的错误处理。

## 文件目的

本模块负责：
- **程序入口点** - 标准C main()函数
- **参数验证** - 确保正确的命令行使用
- **管道协调** - 协调解析→求解→输出流程
- **网格初始化** - 设置干净的数据结构
- **错误管理** - 一致的错误处理和退出码
- **资源协调** - 管理程序状态和流程控制

## 设计理念

### 单一职责协调
- **协调胜于计算** - 将具体任务委托给专门模块
- **清晰流程控制** - 程序阶段的线性进展
- **快速失败方法** - 任何错误条件下的早期终止
- **清晰分离** - 不混合业务逻辑与协调

### 42学校合规性
- **标准main签名** - `int main(int argc, char **argv)`
- **正确退出码** - 成功为0，任何错误为1
- **一致错误输出** - 所有失败情况输出"Error\n"
- **无禁用函数** - 只使用允许的函数和自定义实用工具

---

## 函数文档

### 1. `ft_init_grid`

```c
static void ft_init_grid(t_grid *grid)
```

**目的**：将网格结构初始化为干净的空状态，准备进行求解。

**作用域**：`static` - 内部辅助函数，不暴露给其他模块

**参数**：
- `t_grid *grid` - 指向要初始化的网格结构的指针

**返回值**：
- `void` - 无返回值（初始化函数）

**前置条件**：
- 网格指针必须有效（非NULL）
- 网格结构必须已分配（栈或堆）

**后置条件**：
- 所有网格单元格设为0（空）
- 所有行使用位掩码设为0（无数字被使用）
- 所有列使用位掩码设为0（无数字被使用）
- 网格准备好进行约束求解

#### 算法分析

**嵌套循环结构**：
```c
i = 0;                    // 外循环：行
while (i < SIZE)          // SIZE = 4（行0,1,2,3）
{
    j = 0;                // 内循环：列  
    while (j < SIZE)      // SIZE = 4（列0,1,2,3）
    {
        grid->cells[i][j] = 0;  // 清除每个单元格
        j++;              // 下一列
    }
    grid->row_used[i] = 0;    // 清除行位掩码
    grid->col_used[i] = 0;    // 清除列位掩码  
    i++;                  // 下一行
}
```

**初始化细节**：

1. **单元格初始化** (`grid->cells[i][j] = 0`):
   - 将16个单元格中的每一个设置为0（空/未分配）
   - 0表示尚未放置数字
   - 求解时有效值将为1-4

2. **行位掩码初始化** (`grid->row_used[i] = 0`):
   - 清除每行的约束跟踪
   - 每个位代表一个数字（位0 = 数字1，位1 = 数字2，等等）
   - 0表示行中尚未使用任何数字

3. **列位掩码初始化** (`grid->col_used[i] = 0`):
   - 清除每列的约束跟踪
   - 与行相同的位掩码逻辑
   - 在求解过程中实现快速约束检查

**初始化后的内存布局**：
```c
grid->cells = {
    {0, 0, 0, 0},    // 行0：全空
    {0, 0, 0, 0},    // 行1：全空
    {0, 0, 0, 0},    // 行2：全空
    {0, 0, 0, 0}     // 行3：全空
};
grid->row_used = {0, 0, 0, 0};  // 任何行中都没有使用数字
grid->col_used = {0, 0, 0, 0};  // 任何列中都没有使用数字
```

**性能**：
- **时间复杂度**：O(n²)，其中n=4，所以O(16)常数时间
- **空间复杂度**：O(1) - 只使用循环变量
- **迭代次数**：恰好16次单元格赋值 + 8次位掩码赋值

---

### 2. `main`

```c
int main(int argc, char **argv)
```

**目的**：程序入口点，协调完整的摩天大楼谜题求解过程。

**参数**：
- `int argc` - 命令行参数数量（包括程序名）
- `char **argv` - 命令行参数字符串数组

**返回值**：
- `0` - 成功（谜题已解决并打印）
- `1` - 失败（任何错误条件）

**预期用法**：
```bash
./rush-01 "4 3 2 1 1 2 2 2 4 3 2 1 1 2 2 2"
```

#### 算法流程

**第一阶段：参数验证**
```c
if (argc != 2)
{
    write(1, "Error\n", 6);
    return (1);
}
```
- **预期参数**：程序名 + 1个线索字符串 = 总共2个
- **验证逻辑**：恰好需要2个参数
- **错误处理**：带错误消息的立即终止
- **退出码**：1表示参数错误

**第二阶段：输入解析**
```c
if (!ft_parse_input(argv[1], &input))
{
    write(1, "Error\n", 6);
    return (1);
}
```
- **函数调用**：委托给解析器模块
- **输入源**：`argv[1]`包含线索字符串
- **输出目标**：`input`结构存储解析的线索
- **错误检测**：解析器在任何解析失败时返回0
- **一致错误**：用户看到相同的"Error\n"消息

**第三阶段：网格初始化**
```c
ft_init_grid(&grid);
```
- **清洁状态**：为求解准备空网格
- **无错误检查**：初始化不会失败
- **栈分配**：网格存储在main的栈帧上
- **地址传递**：传递网格地址以进行修改

**第四阶段：谜题求解**
```c
if (!ft_solve_skyscraper(&input, &grid))
{
    write(1, "Error\n", 6);
    return (1);
}
```
- **函数调用**：委托给求解器模块
- **输入数据**：第二阶段解析的线索
- **输出数据**：已解决的网格（就地修改）
- **错误检测**：如果不存在解决方案，求解器返回0
- **无解谜题**：视为错误条件

**第五阶段：解决方案输出**
```c
ft_print_grid(&grid);
return (0);
```
- **函数调用**：委托给输出模块
- **成功路径**：只有在所有先前阶段成功时才到达
- **网格显示**：格式化的4×4解决方案输出
- **退出码**：0表示成功完成

#### 程序流程图
```
main()入口
     ↓
┌─ 验证argc == 2
│    ├─ 成功: 继续
│    └─ 失败: 错误 + 返回1
     ↓
┌─ 解析输入字符串  
│    ├─ 成功: 继续
│    └─ 失败: 错误 + 返回1
     ↓
┌─ 初始化网格（总是成功）
     ↓
┌─ 求解谜题
│    ├─ 成功: 继续  
│    └─ 失败: 错误 + 返回1
     ↓
┌─ 打印解决方案
     ↓
   返回0
```

---

## 错误处理策略

### 一致的错误响应
**所有错误条件都产生相同输出**：
```c
write(1, "Error\n", 6);
return (1);
```

**处理的错误类别**：
1. **参数错误**：错误的命令行参数数量
2. **解析错误**：无效输入格式、错误数字计数、超出范围值
3. **求解器错误**：无解谜题、矛盾线索

### 错误处理好处
- **用户一致性**：无论失败类型如何都有相同的错误消息
- **简单性**：不需要复杂的错误分类
- **42合规性**：完全符合学校要求
- **安全性**：不泄露内部失败的信息

### 无错误条件
- **网格初始化**：不会失败（简单内存清零）
- **解决方案输出**：只在成功求解时调用
- **内存分配**：使用栈分配（自动清理）

---

## 数据结构管理

### 基于栈的分配
```c
t_input input;    // 16个整数（典型64字节）
t_grid  grid;     // 4×4网格 + 位掩码（典型80字节）
```

**优点**：
- **自动清理**：不需要手动内存管理
- **快速分配**：栈分配是O(1)
- **作用域安全**：变量在return时自动清理
- **无泄露**：不可能泄露栈分配的内存

### 阶段间数据流
```
argv[1] → input（解析）
input → grid（求解） 
grid → stdout（输出）
```

**状态转换**：
1. **原始字符串** → **结构化线索**（解析阶段）
2. **空网格** → **已解决网格**（求解阶段）  
3. **网格结构** → **格式化文本**（输出阶段）

---

## 与项目模块的集成

### 模块依赖
```
main.c依赖于：
├── rush.h（类型定义）
├── parser.c（ft_parse_input）
├── solver.c（ft_solve_skyscraper）  
├── output.c（ft_print_grid）
└── system（write函数）
```

### 接口契约

#### **解析器接口**
```c
int ft_parse_input(char *str, t_input *input);
// 返回: 1 = 成功, 0 = 失败
// 修改: 成功时修改input结构
```

#### **求解器接口**  
```c
int ft_solve_skyscraper(t_input *input, t_grid *grid);
// 返回: 1 = 已解决, 0 = 无解
// 修改: 成功时修改grid结构
```

#### **输出接口**
```c
void ft_print_grid(t_grid *grid);
// 返回: void（总是成功）
// 副作用: 写入stdout
```

---

## 性能特征

### 时间复杂度
- **参数检查**：O(1)
- **输入解析**：O(n)，其中n = 输入字符串长度  
- **网格初始化**：O(1) - 固定4×4大小
- **谜题求解**：最坏情况O(4^16)，通过剪枝大大改善
- **输出生成**：O(1) - 固定4×4大小
- **整体**：由求解复杂性主导

### 空间复杂度
- **栈使用**：O(1) - 固定大小结构
- **无动态分配**：所有内存都在栈上
- **递归**：求解器可能使用递归栈空间
- **整体**：O(1) main函数开销 + 求解器需求

### 内存占用
```c
sizeof(t_input) ≈ 64字节   // 16个整数
sizeof(t_grid)  ≈ 80字节   // 16个单元格 + 8个位掩码
总栈:           ≈ 144字节  // 非常轻量级
```

---

## 测试和验证

### 命令行测试

#### **有效输入情况**
```bash
# 标准情况
./rush-01 "4 3 2 1 1 2 2 2 4 3 2 1 1 2 2 2"
# 预期: 4×4解决方案网格

# 边界情况 - 所有不同线索  
./rush-01 "1 2 3 4 4 3 2 1 2 3 1 4 3 1 4 2"
# 预期: 4×4解决方案网格或错误
```

#### **错误情况**
```bash
# 无参数
./rush-01
# 预期: 错误

# 过多参数  
./rush-01 "1 2 3" "4 5 6"
# 预期: 错误

# 无效输入格式
./rush-01 "1 2 3 invalid 5 6 7 8 9 10 11 12 13 14 15 16"
# 预期: 错误

# 无解谜题
./rush-01 "1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1"  
# 预期: 错误
```

### 单元测试方法
```c
// 测试网格初始化
t_grid test_grid;
ft_init_grid(&test_grid);
assert(test_grid.cells[0][0] == 0);
assert(test_grid.row_used[0] == 0);
assert(test_grid.col_used[0] == 0);

// 测试main流程（集成测试）
// 需要使用各种输入进行完整程序执行
```

---

## 42规范合规性

### 函数标准
✅ **函数数量**：2个函数（远低于5个函数限制）  
✅ **函数长度**：两个函数都低于25行  
✅ **函数命名**：`main`（标准），`ft_init_grid`（42约定）  
✅ **静态作用域**：辅助函数正确作用域为static  
✅ **变量命名**：清晰、描述性变量名

### 代码质量
✅ **单一职责**：每个函数都有一个明确目的  
✅ **错误处理**：一致的错误消息和退出码  
✅ **流程控制**：清晰、线性程序进展  
✅ **无副作用**：函数不修改全局状态  
✅ **清晰接口**：定义良好的模块边界

### 样式合规性
✅ **缩进**：正确的制表符缩进  
✅ **大括号**：全程K&R大括号样式  
✅ **间距**：运算符和关键字周围正确间距  
✅ **变量声明**：正确的声明放置  
✅ **行长度**：所有行都低于80个字符  

---

## 演示的最佳实践

### 错误处理模式
- **快速失败**：任何错误时立即返回
- **一致消息**：所有失败都有相同错误输出  
- **正确退出码**：成功为0，任何错误为1
- **无错误传播复杂性**：简单的布尔成功/失败

### 资源管理
- **栈分配**：自动清理，无泄露潜力
- **无动态内存**：避免malloc/free复杂性
- **基于作用域的生命周期**：变量自动清理
- **简单状态管理**：阶段间清晰数据流

### 模块集成
- **清晰接口**：定义良好的函数契约
- **松耦合**：模块只依赖接口，不依赖实现
- **单向流**：无循环依赖
- **错误边界**：每个模块负责自己的验证

---

## 使用示例和场景

### 成功执行
```bash
$ ./rush-01 "4 3 2 1 1 2 2 2 4 3 2 1 1 2 2 2"
4 3 2 1
3 2 1 4
2 1 4 3  
1 4 3 2
$ echo $?
0
```

### 错误场景
```bash
$ ./rush-01
Error
$ echo $?
1

$ ./rush-01 "1 2 3"  
Error
$ echo $?  
1

$ ./rush-01 "impossible puzzle clues"
Error
$ echo $?
1
```

### 与Shell脚本集成
```bash
#!/bin/bash
if ./rush-01 "$1" > solution.txt; then
    echo "谜题已解决！解决方案在solution.txt中"
else  
    echo "谜题无法解决"
fi
```

此文档提供了对程序协调逻辑的完整理解，并演示了一个简单的main函数如何在保持42学校合规性和最佳实践的同时有效协调复杂的谜题求解操作。