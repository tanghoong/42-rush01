# Parser.c 文档

## 概述

`parser.c` 文件包含4×4摩天大楼谜题求解器的输入处理和验证逻辑。本模块负责将原始命令行输入字符串转换为结构化数据，验证格式和内容，并为求解算法准备线索。它实现了根据42学校标准进行综合错误检测的健壮解析。

## 文件目的

本模块处理：
- **字符串标记化** - 将输入分解为单个数字
- **数字提取** - 将字符串数字转换为整数  
- **输入验证** - 确保正确格式和计数
- **范围验证** - 验证线索值在有效范围内（1-4）
- **数据转换** - 将原始输入转换为结构化线索数组
- **错误检测** - 带早期失败检测的综合验证

## 设计理念

### 防御性编程
- **多层验证** - 计数、提取、范围和格式检查
- **早期失败检测** - 任何验证错误时立即返回
- **健壮解析** - 优雅处理空白、错误格式输入
- **无假设** - 验证输入数据的每个方面

### 模块化架构
- **单一职责** - 每个函数处理一个解析方面
- **清晰接口** - 定义良好的输入/输出契约
- **可重用组件** - 用于通用操作的辅助函数
- **错误传播** - 一致的布尔返回模式

---

## 函数文档

### 1. `ft_count_numbers`

```c
static int ft_count_numbers(char *str)
```

**目的**：计算输入字符串中数字令牌的总数。

**作用域**：`static` - 用于输入验证的内部辅助函数

**参数**：
- `char *str` - 要分析的输入字符串

**返回值**：
- `int` - 找到的数字令牌计数（0或正数）

**算法**：
1. **逐字符遍历字符串**
2. **检测数字开始**当遇到第一个数字时
3. **跳过整个数字**通过消费所有连续数字
4. **增加计数器**对每个完整的数字
5. **继续扫描**直到字符串结束

**逐步逻辑**：
```c
count = 0;
i = 0;
while (str[i])                    // 扫描整个字符串
{
    if (ft_is_digit(str[i]))      // 找到数字开始
    {
        count++;                  // 计算此数字
        while (str[i] && ft_is_digit(str[i]))  // 跳过整个数字
            i++;
    }
    else
        i++;                      // 跳过非数字字符
}
```

**示例**：
```c
ft_count_numbers("1 2 3 4")           → 4
ft_count_numbers("12 34 567")         → 3  
ft_count_numbers("1  2   3    4")     → 4（处理多个空格）
ft_count_numbers("1a2b3c")           → 3（忽略字母）
ft_count_numbers("")                  → 0
ft_count_numbers("abc def")           → 0（无数字）
```

**使用情况**：预验证以在详细解析前快速检查输入是否恰好有16个数字。

---

### 2. `ft_parse_number`

```c
static int ft_parse_number(char *str, int *i, int *number)
```

**目的**：从字符串中从位置`*i`开始提取单个整数。

**作用域**：`static` - 用于数字提取的内部辅助

**参数**：
- `char *str` - 包含数字的源字符串
- `int *i` - 指向当前位置的指针（修改为指向数字后）
- `int *number` - 指向存储提取整数值的指针

**返回值**：
- `1` - 成功解析一个数字
- `0` - 在当前位置未找到数字

**算法**：
1. **初始化解析状态**（`j = 0`, `*number = 0`）
2. **处理每个数字**当找到连续数字时
3. **逐步构建数字**使用十进制位值
4. **更新位置**指向数字后
5. **返回成功**如果至少处理了一个数字

**数学逻辑**：
```c
// 对于多位数字如"123"：
// 第一位'1': number = 1
// 第二位'2': number = 1 * 10 + 2 = 12  
// 第三位'3': number = 12 * 10 + 3 = 123
if (j == 0)
    *number = str[*i] - '0';           // 第一位：直接转换
else  
    *number = *number * 10 + (str[*i] - '0');  // 后续：十进制移位+加
```

**位置管理**：
- **输入**：`*i`指向潜在数字的开始
- **处理**：`*i`在每个数字中前进
- **输出**：`*i`指向数字后的第一个非数字

**示例**：
```c
// str = "123 456", i = 0
ft_parse_number(str, &i, &num);  // num = 123, i = 3
// str = "abc", i = 0  
ft_parse_number(str, &i, &num);  // 返回0，i不变
```

**错误处理**：如果没有找到数字返回0，但不推进位置。

---

### 3. `ft_extract_numbers`

```c
static int ft_extract_numbers(char *str, int *numbers)
```

**目的**：将输入字符串中的所有数值提取到整数数组中。

**作用域**：`static` - 用于批量数字提取的内部辅助

**参数**：
- `char *str` - 包含空格分隔数字的输入字符串
- `int *numbers` - 用于存储提取整数的数组（必须有16个空间）

**返回值**：
- `int` - 成功提取的整数数量

**算法**：
1. **初始化扫描**（`i = 0`, `num_idx = 0`）
2. **在每个潜在数字前跳过空白**
3. **如果在当前位置找到数字则解析数字**
4. **存储结果**并前进到下一个数组位置
5. **继续直到**字符串结束或找到16个数字
6. **返回计数**提取的数字

**空白处理**：
```c
while (str[i] && ft_is_space(str[i]))    // 跳过所有空白
    i++;
```
- 处理数字间的多个空格、制表符、换行符
- 对输入中的不规则格式健壮

**数字处理**：
```c
if (str[i] && ft_is_digit(str[i]))       // 有效数字开始
{
    if (ft_parse_number(str, &i, &numbers[num_idx]))  // 提取数字
        num_idx++;                        // 前进数组索引
}
```

**非数字字符处理**：
```c
else if (str[i])                         // 非数字、非空格字符
    i++;                                 // 跳过并继续
```

**安全限制**：
- **最大提取**：在16个数字时停止（谜题要求）
- **边界保护**：`num_idx < 16`防止数组溢出
- **优雅终止**：即使输入继续也返回计数

**示例**：
```c
int nums[16];
ft_extract_numbers("1 2 3 4", nums);           → 4, nums = {1,2,3,4,...}
ft_extract_numbers("1  2   3    4", nums);     → 4（处理间距）
ft_extract_numbers("1,2,3,4", nums);           → 4（忽略逗号）
ft_extract_numbers("1 two 3 four", nums);      → 2, nums = {1,3,...}
```

---

### 4. `ft_validate_clues`

```c
static int ft_validate_clues(int *clues)
```

**目的**：验证所有线索值是否在4×4摩天大楼谜题的有效范围内。

**作用域**：`static` - 内部验证辅助

**参数**：
- `int *clues` - 要验证的16个线索值数组

**返回值**：
- `1` - 所有线索有效（在1-4范围内）
- `0` - 至少一个线索无效

**验证逻辑**：
```c
i = 0;
while (i < 16)                           // 检查所有16个线索
{
    if (clues[i] < 1 || clues[i] > SIZE) // SIZE = 4
        return (0);                      // 遇到无效线索立即失败
    i++;
}
return (1);                              // 所有线索有效
```

**范围要求**：
- **最小值**：1（至少一栋建筑可见）
- **最大值**：4（所有建筑按递增高度顺序可见）
- **无效值**：0、负数、值> 4

**摩天大楼逻辑上下文**：
- **线索= 1**：只有最高建筑（4）从该方向可见
- **线索= 2**：两栋建筑可见（例如高度3,4或2,4）
- **线索= 3**：三栋建筑可见（例如高度2,3,4）
- **线索= 4**：所有四栋建筑可见（高度1,2,3,4）

**示例**：
```c
int valid_clues[] = {4,3,2,1,1,2,2,2,4,3,2,1,1,2,2,2};
ft_validate_clues(valid_clues);         → 1（都在1-4范围内）

int invalid_clues[] = {4,3,2,0,...};   // 包含0
ft_validate_clues(invalid_clues);       → 0（无效）

int invalid_clues2[] = {4,3,2,5,...};  // 包含5  
ft_validate_clues(invalid_clues2);      → 0（无效）
```

---

### 5. `ft_parse_input`

```c
int ft_parse_input(char *str, t_input *input)
```

**目的**：协调完整输入验证和转换过程的主要解析函数。

**作用域**：公共函数（在头文件中导出）- 主要模块接口

**参数**：
- `char *str` - 来自命令行的原始输入字符串
- `t_input *input` - 要用解析的线索填充的输出结构

**返回值**：
- `1` - 成功解析和验证
- `0` - 任何解析或验证失败

**多阶段验证过程**：

#### **第1阶段：空指针检查**
```c
if (!str)
    return (0);
```
- 防止NULL输入上的段错误
- 无效指针的早期终止

#### **第2阶段：计数验证**
```c
if (ft_count_numbers(str) != 16)
    return (0);
```
- 确保输入中恰好16个数字
- 昂贵解析前的快速预检查

#### **第3阶段：提取验证**
```c
if (ft_extract_numbers(str, numbers) != 16)
    return (0);
```
- 双重检查16个数字实际可提取
- 处理计数和提取不同的边界情况

#### **第4阶段：范围验证**
```c
if (!ft_validate_clues(numbers))
    return (0);
```
- 验证所有线索在有效范围内（1-4）
- 确保可以满足谜题约束

#### **第5阶段：数据传输**
```c
i = 0;
while (i < 16)
{
    input->clues[i] = numbers[i];
    i++;
}
return (1);
```
- 将验证的数字复制到输出结构
- 只有在所有验证通过时才到达

**验证冗余**：
- **计数vs提取**：两者都必须返回16以保持一致性
- **多阶段检查**：每个阶段可以捕获不同错误类型
- **深度防御**：多个验证层防止坏数据

**示例**：
```c
t_input input;

// 有效输入
ft_parse_input("4 3 2 1 1 2 2 2 4 3 2 1 1 2 2 2", &input);  → 1

// 无效：错误计数
ft_parse_input("1 2 3 4", &input);                           → 0

// 无效：超出范围  
ft_parse_input("5 3 2 1 1 2 2 2 4 3 2 1 1 2 2 2", &input);  → 0

// 无效：非数字
ft_parse_input("a b c d e f g h i j k l m n o p", &input);    → 0
```

---

## 输入格式规范

### 预期输入结构
解析器期望恰好16个空格分隔的整数，按此顺序表示线索：

```
位置: 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15
含义:  T0 T1 T2 T3 B0 B1 B2 B3 L0 L1 L2 L3 R0 R1 R2 R3
```

其中：
- **T0-T3**：上线索（列0-3）
- **B0-B3**：下线索（列0-3）  
- **L0-L3**：左线索（行0-3）
- **R0-R3**：右线索（行0-3）

### 可视网格表示
```
       T0  T1  T2  T3     ← 位置0-3
       ↓   ↓   ↓   ↓
    L0 →  [·] [·] [·] [·] ← R0  （位置8,12）
    L1 →  [·] [·] [·] [·] ← R1  （位置9,13）  
    L2 →  [·] [·] [·] [·] ← R2  （位置10,14）
    L3 →  [·] [·] [·] [·] ← R3  （位置11,15）
       ↑   ↑   ↑   ↑
       B0  B1  B2  B3     ← 位置4-7
```

### 有效输入示例
```bash
# 标准间距
"4 3 2 1 1 2 2 2 4 3 2 1 1 2 2 2"

# 不规则间距（仍然有效）
"4  3   2    1 1 2 2 2 4 3 2 1 1 2 2 2"

# 混合空白（仍然有效）  
"4	3 2
1 1 2 2 2 4 3 2 1 1 2 2 2"
```

### 无效输入示例
```bash
# 错误计数
"1 2 3 4 5"

# 超出范围值
"0 3 2 1 1 2 2 2 4 3 2 1 1 2 2 2"
"4 3 2 5 1 2 2 2 4 3 2 1 1 2 2 2"

# 非数字内容
"a b c d e f g h i j k l m n o p"
"1 2 three 4 5 6 7 8 9 10 11 12 13 14 15 16"

# 空或null
""
（空指针）
```

---

## 错误检测和验证

### 验证层

#### **第1层：指针安全**
- 空指针检测防止崩溃
- 无效输入指针的早期返回

#### **第2层：计数验证**  
- 预期令牌数量的快速检查
- 防止处理明显错误格式的输入

#### **第3层：提取验证**
- 验证计算的数字实际可解析
- 捕获计数和提取间的不一致性

#### **第4层：范围验证**
- 确保所有值满足谜题约束
- 验证业务逻辑要求

#### **第5层：数据完整性**
- 只有在所有验证通过后才进行最终传输
- 保证输出结构中的清洁数据

### 错误类别

#### **格式错误**
- 参数数量错误
- 预期数字位置的非数字内容
- 错误格式的数字字符串

#### **范围错误**
- 小于1的值
- 大于4的值  
- 零或负值

#### **结构错误**
- 空输入指针
- 计数vs提取不一致
- 意外字符序列

### 验证健壮性

#### **空白容忍**
```c
// 所有等价输入：
"1 2 3 4"        // 单空格
"1  2   3    4"  // 多空格  
"1\t2\n3\r4"     // 混合空白
```

#### **错误恢复**
- 无部分解析 - 全有或全无方法
- 带布尔返回的干净失败状态
- 无内存泄漏或悬空状态

---

## 与项目的集成

### 模块依赖
```
parser.c依赖于：
├── rush.h（类型定义：t_input, SIZE）
├── utils.c（ft_is_digit, ft_is_space）  
└── system（无直接系统调用）
```

### 接口契约
```c
int ft_parse_input(char *str, t_input *input);
```

**前置条件**：
- `str`可以为NULL（安全处理）
- `input`必须指向有效的t_input结构

**后置条件**：
- 返回1：`input->clues`包含16个有效值（1-4）
- 返回0：`input`结构不变，无副作用

**使用模式**：
```c
// 在main.c中
t_input input;
if (!ft_parse_input(argv[1], &input))
{
    // 处理错误 - 无需清理
    write(1, "Error\n", 6);  
    return (1);
}
// 安全使用input.clues[0-15]
```

### 数据流
```
命令行 → argv[1] → ft_parse_input() → input.clues[16] → 求解器
```

---

## 性能分析

### 时间复杂度

#### **每个函数**：
- **ft_count_numbers**：O(n) - 单次字符串扫描
- **ft_parse_number**：O(k) - k位数字每个数字  
- **ft_extract_numbers**：O(n) - 带解析的单次字符串扫描
- **ft_validate_clues**：O(1) - 总是检查恰好16个值
- **ft_parse_input**：O(n) - 由字符串扫描主导

其中n = 输入字符串长度，k = 每个数字的平均位数

#### **整体**：O(n) - 输入字符串长度线性

### 空间复杂度
- **局部数组**：`numbers[16]` = 64字节临时存储
- **循环变量**：O(1)额外空间
- **无动态分配**：所有内存都在栈上
- **整体**：O(1) - 常数空间使用

### 优化特征
- **早期终止**：验证失败时立即返回
- **单次遍历算法**：大多数操作只扫描字符串一次
- **无冗余工作**：每个验证层添加独特价值
- **最小复制**：直接提取到最终存储

---

## 测试和验证

### 单元测试策略

#### **函数级测试**
```c
// ft_count_numbers测试
assert(ft_count_numbers("1 2 3 4") == 4);
assert(ft_count_numbers("12 34") == 2);
assert(ft_count_numbers("") == 0);
assert(ft_count_numbers("abc") == 0);

// ft_validate_clues测试  
int valid[] = {1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4};
assert(ft_validate_clues(valid) == 1);
int invalid[] = {0,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4};
assert(ft_validate_clues(invalid) == 0);
```

#### **集成测试**
```c
t_input input;

// 有效完整输入
assert(ft_parse_input("4 3 2 1 1 2 2 2 4 3 2 1 1 2 2 2", &input) == 1);
assert(input.clues[0] == 4);
assert(input.clues[15] == 2);

// 无效输入
assert(ft_parse_input("1 2 3", &input) == 0);
assert(ft_parse_input(NULL, &input) == 0);
```

### 边界情况测试

#### **边界条件**
- 空字符串输入
- 恰好16个数字（有效）
- 15或17个数字（无效）
- 所有最小值（1,1,1,...）
- 所有最大值（4,4,4,...）

#### **错误格式输入**
- 混合数字和非数字
- 超出有效范围的数字
- 不寻常的空白模式
- 非常长的输入字符串

### 错误条件测试
```bash
# 验证测试工具
test_cases=(
    ""                                   # 空
    "1 2 3"                             # 太少  
    "1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17"  # 太多
    "0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15"      # 超出范围（0）
    "1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16"     # 超出范围（5）
    "a b c d e f g h i j k l m n o p"            # 非数字
)

for test in "${test_cases[@]}"; do
    if ./rush-01 "$test" 2>/dev/null; then
        echo "FAIL: 应该拒绝 '$test'"
    else
        echo "PASS: 正确拒绝 '$test'"
    fi
done
```

---

## 42规范合规性

### 函数标准
✅ **函数数量**：5个函数（恰好在限制处）  
✅ **函数长度**：重构后所有函数≤25行  
✅ **函数命名**：全部使用`ft_`前缀  
✅ **静态函数**：内部辅助函数正确作用域  
✅ **参数清晰**：清晰、描述性参数名

### 代码质量
✅ **单一职责**：每个函数有一个明确解析任务  
✅ **错误处理**：一致的布尔返回模式  
✅ **输入验证**：综合防御性编程  
✅ **无副作用**：函数不修改全局状态  
✅ **清晰逻辑流程**：易于遵循的验证序列

### 样式合规性
✅ **缩进**：全程正确制表符缩进  
✅ **大括号**：K&R大括号样式  
✅ **间距**：运算符和关键字周围正确间距  
✅ **变量声明**：正确声明放置  
✅ **行长度**：所有行低于80字符  
✅ **注释**：代码自文档化，无过度注释

---

## 演示的最佳实践

### 防御性编程
- **空指针检查**：防止段错误
- **边界检查**：防止缓冲区溢出  
- **范围验证**：确保数据满足业务规则
- **多层验证**：深度防御方法

### 健壮解析
- **空白容忍**：处理各种输入格式
- **错误恢复**：无副作用的干净失败
- **输入清理**：处理前验证
- **早期终止**：无效输入时快速失败

### 清洁架构
- **关注点分离**：每个函数处理一个方面
- **清晰接口**：定义良好的输入/输出契约
- **可组合函数**：辅助函数构建复杂性
- **可测试设计**：易于单元测试个别组件

### 内存安全
- **栈分配**：无动态内存管理
- **边界保护**：数组访问在限制内
- **无缓冲区溢出**：安全字符串处理
- **自动清理**：栈变量自动清理

此文档提供了对输入处理管道的完整理解，该管道将原始命令行参数转换为已验证的结构化数据，准备用于摩天大楼谜题求解算法。