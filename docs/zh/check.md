# Check.c 文档

## 概述

`check.c` 文件包含可见性验证函数，用于验证已完成或部分完成的网格解决方案是否满足摩天大楼谜题的线索。这些函数实现了根据谜题规则确定建筑物从不同方向是否可见的核心逻辑。

## 文件目的

本模块负责：
- **行可见性验证** - 检查左右线索
- **列可见性验证** - 检查上下线索  
- **完整网格验证** - 验证所有线索是否满足
- **解决方案验证** - 确认已解决的谜题正确

## 摩天大楼可见性规则

### 基本概念
在摩天大楼谜题中，数字1-4代表建筑物的高度。网格周围的可见性线索表示从该方向能"看到"多少栋建筑物。

### 可见性逻辑
- 较高的建筑物会**遮挡**其后面较矮的建筑物
- 只能看到比前面所有建筑物都**更高**的建筑物
- 相同高度或更矮的建筑物会被**隐藏**

### 示例
```
行: [1, 3, 4, 2]
从左→右: 看到1，然后3（遮挡1），然后4（遮挡1,3）= 3个可见
从右←左: 看到2，然后4（遮挡2）= 2个可见
```

---

## 函数文档

### 1. `ft_check_row_visibility`

```c
static int ft_check_row_visibility(t_grid *grid, int row, t_input *input)
```

**目的**：验证单行的可见性线索（左右方向）。

**参数**：
- `t_grid *grid` - 当前网格状态
- `int row` - 要检查的行索引（0-3）
- `t_input *input` - 包含线索数组

**算法**：
1. **提取线索**：
   - 左线索：`input->clues[8 + row]`（线索8-11）
   - 右线索：`input->clues[12 + row]`（线索12-15）

2. **计算可见建筑物**：
   - 从左：使用`ft_count_visible_left(grid->cells[row])`
   - 从右：使用`ft_count_visible_right(grid->cells[row])`

3. **验证**：
   - 如果任一方向不匹配其线索则返回`0`
   - 如果两个方向都匹配其线索则返回`1`

**线索映射**：
```
行的线索数组索引：
行0: 左=线索[8],  右=线索[12]
行1: 左=线索[9],  右=线索[13]  
行2: 左=线索[10], 右=线索[14]
行3: 左=线索[11], 右=线索[15]
```

**示例**：
```c
// 网格行: [4, 3, 2, 1]
// 左线索 = 4，右线索 = 1
// 左可见性: 4个建筑物可见（4，然后没有更高的）
// 右可见性: 1个建筑物可见（只有4比1,2,3高）
// 结果: 两个都匹配，返回1
```

---

### 2. `ft_check_col_visibility`

```c
static int ft_check_col_visibility(t_grid *grid, int col, t_input *input)
```

**目的**：验证单列的可见性线索（上下方向）。

**参数**：
- `t_grid *grid` - 当前网格状态  
- `int col` - 要检查的列索引（0-3）
- `t_input *input` - 包含线索数组

**算法**：
1. **提取线索**：
   - 上线索：`input->clues[col]`（线索0-3）
   - 下线索：`input->clues[4 + col]`（线索4-7）

2. **计算可见建筑物**：
   - 从上：使用`ft_count_visible_top(grid, col)`
   - 从下：使用`ft_count_visible_bottom(grid, col)`

3. **验证**：
   - 如果任一方向不匹配其线索则返回`0`
   - 如果两个方向都匹配其线索则返回`1`

**线索映射**：
```
列的线索数组索引：
列0: 上=线索[0], 下=线索[4]
列1: 上=线索[1], 下=线索[5]
列2: 上=线索[2], 下=线索[6]  
列3: 上=线索[3], 下=线索[7]
```

**示例**：
```c
// 网格列: [1, 2, 3, 4]（从上到下）
// 上线索 = 4，下线索 = 1
// 上可见性: 4个建筑物可见（每个都比前一个高）
// 下可见性: 1个建筑物可见（只有4可见）
// 结果: 两个都匹配，返回1
```

---

### 3. `ft_check_visibility`

```c
int ft_check_visibility(t_grid *grid, t_input *input)
```

**目的**：验证整个网格是否符合所有16个可见性线索。

**参数**：
- `t_grid *grid` - 要验证的完整网格
- `t_input *input` - 包含所有16个线索

**算法**：
1. **遍历所有位置**（0-3）：
   - 使用`ft_check_row_visibility`检查行`i`
   - 使用`ft_check_col_visibility`检查列`i`

2. **早期终止**：
   - 如果任何行或列失败则立即返回`0`
   - 只有在所有检查通过时才继续

3. **完整验证**：
   - 只有当所有4行**和**所有4列都通过时才返回`1`

**使用上下文**：
此函数在以下情况被调用：
- 当回溯算法填满所有16个格子时
- 在输出前验证完整解决方案
- 作为求解器中的最终验证步骤

**逻辑流程**：
```
对于i = 0到3：
  ├─ 检查行i可见性（左+右线索）
  │  └─ 如果失败: 返回0
  └─ 检查列i可见性（上+下线索）
     └─ 如果失败: 返回0
返回1（全部通过）
```

---

## 与求解器的集成

### 调用层次
```
ft_solve_skyscraper()
└── ft_backtrack()
    └── ft_check_visibility() ← 当pos == 16时调用（网格填满）
        ├── ft_check_row_visibility() ← 对每行
        └── ft_check_col_visibility() ← 对每列
```

### 依赖函数
检查函数依赖于`vis.c`中的可见性计数：
- `ft_count_visible_left(int *row)` - 从行左侧计数
- `ft_count_visible_right(int *row)` - 从行右侧计数  
- `ft_count_visible_top(t_grid *grid, int col)` - 从列顶部计数
- `ft_count_visible_bottom(t_grid *grid, int col)` - 从列底部计数

---

## 线索数组结构

`input->clues[]`中的16个线索组织如下：
```
索引  | 方向    | 位置
------|---------|----------
0-3   | 上      | 列0,1,2,3
4-7   | 下      | 列0,1,2,3  
8-11  | 左      | 行0,1,2,3
12-15 | 右      | 行0,1,2,3
```

**可视化表示**：
```
       0   1   2   3     ← 上线索（索引0-3）
       ↓   ↓   ↓   ↓
    8→ [·] [·] [·] [·] ←12
    9→ [·] [·] [·] [·] ←13  
   10→ [·] [·] [·] [·] ←14
   11→ [·] [·] [·] [·] ←15
       ↑   ↑   ↑   ↑
       4   5   6   7     ← 下线索（索引4-7）
```

---

## 错误处理

### 返回值
- **返回0**：可见性约束违反
- **返回1**：所有可见性约束满足

### 验证点
1. **行验证**：左右线索都必须匹配
2. **列验证**：上下线索都必须匹配  
3. **完整验证**：所有4行**和**所有4列都必须通过

### 失败情况
- 计算的可见性≠预期的线索值
- 任何单个方向不匹配都会使整个检查失败
- 用于回溯：拒绝无效放置

---

## 性能考虑

### 时间复杂度
- **每行检查**：O(4) - 扫描4个单元格两次（左+右）
- **每列检查**：O(4) - 扫描4个单元格两次（上+下）  
- **完整检查**：O(16) - 4行×O(4) + 4列×O(4)

### 空间复杂度
- **O(1)** - 只使用局部变量存储索引和线索值
- 不需要额外的数据结构或递归

### 优化
- **早期终止**：在第一个约束违反时立即返回
- **静态函数**：行/列检查是内部辅助函数
- **直接数组访问**：无复杂指针运算

---

## 测试示例

### 有效情况
```c
网格: [4,3,2,1]  线索: 左=4, 右=1
      [3,4,1,2]         左=2, 右=2  
      [2,1,4,3]         左=2, 右=2
      [1,2,3,4]         左=4, 右=1

结果: 所有可见性检查通过 → 返回1
```

### 无效情况  
```c
网格: [1,2,3,4]  线索: 左=4, 右=1
      [2,3,4,1]         左=3, 右=2
      [3,4,1,2]         左=2, 右=2  
      [4,1,2,3]         左=1, 右=2

行0: 左_可见=4, 左_线索=4 ✓, 右_可见=1, 右_线索=1 ✓
行1: 左_可见=3, 左_线索=3 ✓, 右_可见=2, 右_线索=2 ✓
但列检查可能失败...
结果: 如果任何检查失败 → 返回0
```

---

## 42规范合规性

### 函数标准
✅ **函数长度**：所有函数≤25行  
✅ **函数命名**：所有函数都使用`ft_`前缀  
✅ **静态函数**：辅助函数正确作用域  
✅ **变量命名**：清晰、描述性名称  
✅ **返回一致性**：始终0（失败）或1（成功）  

### 代码质量
✅ **单一职责**：每个函数都有一个明确目的  
✅ **清晰逻辑流程**：易于遵循的验证步骤  
✅ **无副作用**：纯验证函数  
✅ **一致风格**：匹配项目约定  

此文档提供了对可见性验证逻辑的完整理解，该逻辑确保摩天大楼谜题解决方案在数学上正确并满足所有给定线索。