# Solver.c 文档

## 概述

`solver.c` 文件包含4×4摩天大楼谜题的核心求解引擎。本模块使用通过位掩码进行高效约束检查的回溯约束满足算法。它代表了谜题求解器的核心，数学逻辑与算法效率相结合，找到满足所有可见性线索的有效解决方案。

## 文件目的

本模块处理：
- **约束满足** - 确保行/列中没有重复数字
- **回溯算法** - 系统地探索解决方案空间
- **高效约束检查** - 使用位掩码进行快速验证
- **状态管理** - 通过适当清理放置和移除值
- **解决方案验证** - 与可见性检查集成进行完整验证
- **优化** - 早期剪枝无效分支以提高性能

## 设计理念

### 约束满足问题（CSP）
摩天大楼谜题是一个经典的CSP，具有：
- **变量**：16个网格单元格（每个需要一个1-4的值）
- **域**：每个变量可以取值{1, 2, 3, 4}
- **约束**： 
  - 行唯一性（每行恰好有1,2,3,4一次）
  - 列唯一性（每列恰好有1,2,3,4一次）
  - 可见性约束（网格周围的线索必须满足）

### 回溯策略
- **系统探索**：以有组织的方式尝试所有可能性
- **早期剪枝**：拒绝不能导致有效完整解决方案的部分解决方案
- **状态恢复**：回溯时撤销更改以探索替代方案
- **深度优先搜索**：在尝试替代方案之前完全探索一个分支

---

## 算法概述

### 回溯过程
```
1. 如果所有16个位置填满 → 验证完整解决方案
2. 找到下一个空位置
3. 对于每个可能值（1-4）：
   a. 检查值是否违反约束
   b. 如果有效：放置值并递归到下一个位置
   c. 如果递归成功 → 找到解决方案
   d. 如果递归失败 → 移除值并尝试下一个
4. 如果没有值有效 → 回溯到前一个位置
```

### 约束检查策略
- **位掩码效率**：O(1)约束检查而不是O(n)数组扫描
- **立即验证**：放置前检查约束，而不是放置后
- **完整验证**：只有当网格完成时才进行最终可见性检查

---

## 函数文档

### 1. `ft_is_valid_placement`

```c
int ft_is_valid_placement(t_grid *grid, int row, int col, int val)
```

**目的**：确定值是否可以合法地放置在特定网格位置而不违反行/列唯一性约束。

**参数**：
- `t_grid *grid` - 当前带约束跟踪的网格状态
- `int row` - 目标行（0-3）
- `int col` - 目标列（0-3）  
- `int val` - 要放置的值（1-4）

**返回值**：
- `1` - 放置有效（无约束违反）
- `0` - 放置违反约束（行或列重复）

**算法**：
```c
bit = 1 << (val - 1);                    // 将值转换为位掩码
if (grid->row_used[row] & bit)           // 检查行约束
    return (0);                          // 值已在行中使用
if (grid->col_used[col] & bit)           // 检查列约束  
    return (0);                          // 值已在列中使用
return (1);                              // 有效放置
```

**位掩码逻辑**：
- **值1**：`bit = 1 << 0 = 0001`（位0）
- **值2**：`bit = 1 << 1 = 0010`（位1）  
- **值3**：`bit = 1 << 2 = 0100`（位2）
- **值4**：`bit = 1 << 3 = 1000`（位3）

**约束检查**：
```c
// 示例：row_used[0] = 0101（已使用值1和3）
// 检查值2：bit = 0010
// 0101 & 0010 = 0000（false）→ 值2可用
// 检查值1：bit = 0001  
// 0101 & 0001 = 0001（true）→ 值1已使用
```

**性能**：O(1) - 使用位运算操作而不是O(n)数组扫描的常数时间。

---

### 2. `ft_place_value`

```c
void ft_place_value(t_grid *grid, int row, int col, int val)
```

**目的**：在网格中放置值并更新约束跟踪结构。

**参数**：
- `t_grid *grid` - 要修改的网格
- `int row` - 目标行（0-3）
- `int col` - 目标列（0-3）
- `int val` - 要放置的值（1-4）

**返回值**：`void` - 无返回（状态修改函数）

**算法**：
```c
bit = 1 << (val - 1);                    // 将值转换为位掩码
grid->cells[row][col] = val;             // 在网格中放置值
grid->row_used[row] |= bit;              // 标记值在行中已使用
grid->col_used[col] |= bit;              // 标记值在列中已使用
```

**状态更新**：
1. **网格修改**：将单元格设置为指定值
2. **行约束更新**：设置表示值在此行中已使用的位
3. **列约束更新**：设置表示值在此列中已使用的位

**示例**：
```c
// 之前：grid->cells[1][2] = 0, row_used[1] = 0001, col_used[2] = 0010
ft_place_value(grid, 1, 2, 3);
// 之后：grid->cells[1][2] = 3, row_used[1] = 0101, col_used[2] = 0110
```

**位掩码更新逻辑**：
- **OR操作（`|=`）**：设置对应值的位
- **保留现有位**：其他值保持标记为已使用
- **原子操作**：所有三个更新保持一致状态

---

### 3. `ft_remove_value`

```c
void ft_remove_value(t_grid *grid, int row, int col, int val)
```

**目的**：从网格中移除值并更新约束跟踪（回溯清理）。

**参数**：
- `t_grid *grid` - 要修改的网格
- `int row` - 目标行（0-3）
- `int col` - 目标列（0-3）
- `int val` - 要移除的值（1-4）

**返回值**：`void` - 无返回（状态恢复函数）

**算法**：
```c
bit = 1 << (val - 1);                    // 将值转换为位掩码
grid->cells[row][col] = 0;               // 清除单元格（0 = 空）
grid->row_used[row] &= ~bit;             // 在行中取消标记值
grid->col_used[col] &= ~bit;             // 在列中取消标记值
```

**状态恢复**：
1. **网格清理**：将单元格重置为空状态（0）
2. **行约束清理**：清除表示值不再在行中使用的位
3. **列约束清理**：清除表示值不再在列中使用的位

**位掩码清除逻辑**：
- **NOT操作（`~`）**：反转位掩码（0001变成1110）
- **AND操作（`&=`）**：只清除目标位
- **保留其他位**：其他值保持标记为已使用

**示例**：
```c
// 之前：grid->cells[1][2] = 3, row_used[1] = 0101, col_used[2] = 0110
ft_remove_value(grid, 1, 2, 3);
// 之后：grid->cells[1][2] = 0, row_used[1] = 0001, col_used[2] = 0010
```

**对回溯的关键性**：确保在探索替代分支时干净的状态恢复。

---

### 4. `ft_backtrack`

```c
static int ft_backtrack(t_grid *grid, t_input *input, int pos)
```

**目的**：系统探索所有可能解决方案的核心递归回溯算法。

**作用域**：`static` - 内部引擎函数，不暴露给模块外部

**参数**：
- `t_grid *grid` - 当前网格状态（在搜索过程中修改）
- `t_input *input` - 用于最终验证的谜题线索
- `int pos` - 线性遍历中的当前位置（0-15）

**返回值**：
- `1` - 找到解决方案（成功）
- `0` - 从当前状态不可能有解决方案

**位置映射**：
```c
row = pos / SIZE;    // 整数除法：pos 0-3 → 行0，pos 4-7 → 行1，等等
col = pos % SIZE;    // 模运算：pos 0,4,8,12 → 列0，pos 1,5,9,13 → 列1，等等
```

**线性位置布局**：
```
pos:  0  1  2  3      行0
      4  5  6  7      行1  
      8  9 10 11      行2
     12 13 14 15      行3
```

**算法流程**：

#### **基础情况 - 完整网格**
```c
if (pos == 16)
    return (ft_check_visibility(grid, input));
```
- 所有16个位置填满 → 根据可见性线索验证完整解决方案
- 委托给`check.c`模块进行综合可见性验证
- 只有在满足所有线索时才返回1

#### **跳过已填单元格**
```c
if (grid->cells[row][col] != 0)
    return (ft_backtrack(grid, input, pos + 1));
```
- 某些位置可能预填（未来优化）
- 跳到下一个位置而不尝试值
- 保持算法通用性

#### **尝试所有可能值**
```c
val = 1;
while (val <= SIZE)                      // 尝试值1, 2, 3, 4
{
    if (ft_is_valid_placement(grid, row, col, val))
    {
        ft_place_value(grid, row, col, val);         // 做移动
        if (ft_backtrack(grid, input, pos + 1))      // 递归
            return (1);                              // 找到解决方案！
        ft_remove_value(grid, row, col, val);        // 回溯
    }
    val++;
}
return (0);                              // 未找到有效值
```

**递归树示例**：
```
pos=0, 尝试 val=1
├─ pos=1, 尝试 val=1（无效 - 相同行）
├─ pos=1, 尝试 val=2
│  ├─ pos=2, 尝试 val=1（无效 - 相同行）  
│  ├─ pos=2, 尝试 val=3
│  │  └─ ... 继续递归
│  └─ pos=2, 尝试 val=4
└─ pos=1, 尝试 val=3
   └─ ... 探索此分支
```

**性能特征**：
- **最好情况**：O(1) - 幸运的第一次猜测有效
- **平均情况**：取决于约束紧密性和启发式
- **最坏情况**：O(4^16) - 尝试每种可能性
- **实际性能**：由于约束传播大大改善

---

### 5. `ft_solve_skyscraper`

```c
int ft_solve_skyscraper(t_input *input, t_grid *grid)
```

**目的**：启动求解过程的公共接口函数。

**作用域**：公共函数（在头文件中导出）- 主求解器接口

**参数**：
- `t_input *input` - 解析的谜题线索
- `t_grid *grid` - 要用解决方案填充的空网格

**返回值**：
- `1` - 谜题成功解决
- `0` - 不存在解决方案（无解谜题）

**算法**：
```c
return (ft_backtrack(grid, input, 0));
```

**接口作用**：
- **抽象层**：隐藏回溯实现细节
- **清洁API**：调用者的简单成功/失败接口
- **起始点**：从位置0开始搜索（左上角）
- **状态管理**：假设网格已正确初始化

**使用模式**：
```c
// 在main.c中
t_grid grid;
t_input input;
ft_init_grid(&grid);                     // 清洁状态
if (ft_solve_skyscraper(&input, &grid))  // 尝试求解
{
    ft_print_grid(&grid);                // 成功：打印解决方案
}
else
{
    write(1, "Error\n", 6);              // 失败：无解决方案
}
```

---

## 约束满足理论

### 问题分类
4×4摩天大楼谜题是一个**约束满足问题（CSP）**，具有：

#### **变量**：X = {x₀₀, x₀₁, ..., x₃₃}
- 16个需要值的网格位置

#### **域**：D = {1, 2, 3, 4}  
- 每个位置可以有4个高度值中的任何一个

#### **约束**：C = {行，列，可见性}
1. **行约束**：每行恰好包含{1,2,3,4}一次
2. **列约束**：每列恰好包含{1,2,3,4}一次  
3. **可见性约束**：必须满足边缘周围的线索

### 搜索空间分析

#### **总组合**
- **无约束**：4^16 = 4,294,967,296种可能性
- **有行/列约束**：4! × 4! = 576个拉丁方
- **有可见性约束**：更小（通常1个唯一解决方案）

#### **约束传播好处**
- **早期剪枝**：消除违反行/列唯一性的分支
- **减少搜索**：只探索有效的部分解决方案
- **性能增益**：比蛮力快几个数量级

---

## 算法复杂度分析

### 时间复杂度

#### **最好情况**：O(1)
- 第一次猜测立即找到解决方案
- 对简单谜题罕见但可能

#### **平均情况**：O(n^k)其中n=4，k≪16
- 取决于约束紧密性和谜题难度
- 可见性约束显著剪枝搜索空间
- 典型性能远好于最坏情况

#### **最坏情况**：O(4^16)
- 必须探索整个搜索树
- 只对极度约束或无解谜题
- 通过约束传播和早期终止缓解

### 空间复杂度

#### **递归栈**：O(d)其中d≤16
- 最大递归深度为16（位置数）
- 每个栈帧使用常数空间
- 总栈空间≈16×32字节= 512字节

#### **网格存储**：O(1)
- 固定4×4网格与位掩码
- 总空间≈80字节（常数）

#### **整体**：O(1)空间 - 非常节省内存

### 性能优化

#### **位掩码操作**
- **约束检查**：O(1)而不是O(n)数组扫描
- **状态更新**：O(1)位运算操作
- **内存效率**：紧凑约束表示

#### **早期终止**
- **无效放置**：不递归立即返回
- **完整验证**：只有在所有位置填满时
- **剪枝**：早期消除无效分支

#### **线性位置遍历**
- **缓存友好**：顺序内存访问模式
- **简单算术**：快速行/列计算
- **可预测**：无复杂位置选择启发式

---

## 与项目模块的集成

### 模块依赖
```
solver.c依赖于：
├── rush.h（t_grid, t_input, SIZE定义）
├── check.c（ft_check_visibility用于完整验证）
└── 无直接I/O依赖
```

### 数据流
```
main.c → ft_solve_skyscraper() → ft_backtrack() → ft_check_visibility()
         ↑                        ↓
      成功/失败            约束验证
```

### 接口契约

#### **输入契约**：
- `grid`必须正确初始化（所有单元格= 0，位掩码= 0）
- `input`必须包含16个验证的线索（范围1-4）

#### **输出契约**：
- 返回1：`grid`包含有效完整解决方案
- 返回0：`grid`状态未定义（调用者不应使用）

#### **副作用**：
- 在搜索过程中修改网格（但失败时恢复）
- 无全局状态修改
- 无I/O操作

---

## 调试和分析工具

### 状态检查
```c
// 添加开发调试函数：
void debug_print_state(t_grid *grid, int pos)
{
    printf("位置%d（行%d，列%d）：\n", pos, pos/SIZE, pos%SIZE);
    printf("行%d已使用：%04b\n", pos/SIZE, grid->row_used[pos/SIZE]);
    printf("列%d已使用：%04b\n", pos%SIZE, grid->col_used[pos%SIZE]);
    // 打印部分网格状态...
}
```

### 性能分析
```c
// 添加分析计数器：
static int placement_attempts = 0;
static int backtrack_calls = 0;
static int constraint_checks = 0;

// 跟踪算法效率和优化机会
```

### 解决方案验证
```c
// 独立验证函数：
int verify_solution(t_grid *grid)
{
    // 检查所有行都有1,2,3,4
    // 检查所有列都有1,2,3,4  
    // 根据原始线索验证
    return (all_constraints_satisfied);
}
```

---

## 测试和验证

### 单元测试策略

#### **约束函数**
```c
// 测试约束检查
t_grid test_grid = {0};
test_grid.row_used[0] = 0x05;  // 行0中已使用值1,3
assert(ft_is_valid_placement(&test_grid, 0, 0, 2) == 1);  // 值2可以
assert(ft_is_valid_placement(&test_grid, 0, 0, 1) == 0);  // 值1被阻止

// 测试放置/移除  
ft_place_value(&test_grid, 0, 0, 2);
assert(test_grid.cells[0][0] == 2);
assert(test_grid.row_used[0] == 0x07);  // 现在使用1,2,3
ft_remove_value(&test_grid, 0, 0, 2);  
assert(test_grid.cells[0][0] == 0);
assert(test_grid.row_used[0] == 0x05);  // 回到使用1,3
```

#### **算法测试**
```c
// 用已知可解谜题测试
t_input known_input = {{4,3,2,1,1,2,2,2,4,3,2,1,1,2,2,2}};
t_grid test_grid;
ft_init_grid(&test_grid);
assert(ft_solve_skyscraper(&known_input, &test_grid) == 1);

// 用不可能谜题测试  
t_input impossible = {{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1}};
ft_init_grid(&test_grid);
assert(ft_solve_skyscraper(&impossible, &test_grid) == 0);
```

### 性能测试
```bash
# 用各种谜题难度基准测试
time ./rush-01 "4 3 2 1 1 2 2 2 4 3 2 1 1 2 2 2"  # 简单
time ./rush-01 "2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2"  # 困难  
time ./rush-01 "1 1 1 1 4 4 4 4 1 1 1 1 4 4 4 4"  # 不可能
```

### 正确性验证
```c
// 验证解决方案满足所有约束
int verify_complete_solution(t_grid *grid, t_input *input)
{
    // 检查行唯一性
    for (int row = 0; row < SIZE; row++)
        if (!check_row_unique(grid->cells[row])) return 0;
    
    // 检查列唯一性  
    for (int col = 0; col < SIZE; col++)
        if (!check_column_unique(grid, col)) return 0;
        
    // 检查可见性约束
    return ft_check_visibility(grid, input);
}
```

---

## 42规范合规性

### 函数标准
✅ **函数数量**：重构后5个函数（恰好在限制处）  
✅ **函数长度**：所有函数≤25行  
✅ **函数命名**：全部使用`ft_`前缀约定  
✅ **静态作用域**：内部函数正确作用域  
✅ **参数清晰**：清晰、描述性参数名

### 算法质量
✅ **单一职责**：每个函数有一个明确算法任务  
✅ **清洁接口**：定义良好的输入/输出契约  
✅ **状态管理**：正确状态修改和恢复  
✅ **错误处理**：带布尔返回的干净失败模式  
✅ **无副作用**：函数不修改意外状态

### 代码样式
✅ **缩进**：全程正确制表符缩进  
✅ **大括号**：一致应用K&R大括号样式  
✅ **变量命名**：清晰、数学变量名  
✅ **逻辑清晰**：算法流程易于遵循  
✅ **无过度注释**：代码自文档化

---

## 高级主题和扩展

### 算法改进

#### **变量排序启发式**
- **最受约束变量**：选择有效值最少的位置
- **度启发式**：选择影响最多约束的位置
- **当前**：简单从左到右、从上到下排序

#### **值排序启发式**  
- **最少约束值**：选择为其他位置消除最少选项的值
- **当前**：按1,2,3,4顺序尝试值

#### **约束传播**
- **弧一致性**：消除不能导致有效解决方案的值
- **前向检查**：检查未分配变量上的约束
- **当前**：放置时基本约束检查

### 可扩展性考虑

#### **推广到N×N**
```c
// 当前：为4×4优化
#define SIZE 4
// 扩展：参数化大小
int solve_nxn_skyscraper(int n, t_input *input, t_grid *grid);
```

#### **多解决方案**
```c
// 当前：找第一个解决方案
// 扩展：找所有解决方案
int find_all_solutions(t_input *input, t_grid solutions[], int max_solutions);
```

### 性能优化

#### **迭代深化**
- 首先尝试回溯较少的解决方案
- 逐渐增加搜索深度
- 更好地快速找到解决方案

#### **并行搜索**  
- 在线程间分发不同值选择
- 共享状态需要同步
- 显著加速的潜力

此文档提供了对约束满足算法的完整理解，该算法构成摩天大楼谜题求解器的数学和计算核心，演示了理论计算机科学概念如何转化为实用、高效的代码。